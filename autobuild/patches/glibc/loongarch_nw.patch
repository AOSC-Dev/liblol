diff --git a/sysdeps/loongarch/nptl/nptl-init.c b/sysdeps/loongarch/nptl/nptl-init.c
new file mode 100644
index 00000000..372d470f
--- /dev/null
+++ b/sysdeps/loongarch/nptl/nptl-init.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include_next <nptl/nptl-init.c>
diff --git a/sysdeps/loongarch/nptl/pthread_create.c b/sysdeps/loongarch/nptl/pthread_create.c
new file mode 100644
index 00000000..5baa8f59
--- /dev/null
+++ b/sysdeps/loongarch/nptl/pthread_create.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include_next <nptl/pthread_create.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/aio_misc.h b/sysdeps/unix/sysv/linux/loongarch/aio_misc.h
new file mode 100644
index 00000000..951c1846
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/aio_misc.h
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/aio-misc.h>
diff --git a/sysdeps/unix/sysv/linux/loongarch/bits/signum.h b/sysdeps/unix/sysv/linux/loongarch/bits/signum.h
index 3cad0b19..445c4864 100644
--- a/sysdeps/unix/sysv/linux/loongarch/bits/signum.h
+++ b/sysdeps/unix/sysv/linux/loongarch/bits/signum.h
@@ -55,4 +55,6 @@
 #undef	__SIGRTMAX
 #define __SIGRTMAX	127
 
+#define _NW_NSIG        64
+
 #endif	/* <signal.h> included.  */
diff --git a/sysdeps/unix/sysv/linux/loongarch/epoll_pwait.c b/sysdeps/unix/sysv/linux/loongarch/epoll_pwait.c
new file mode 100644
index 00000000..3613db75
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/epoll_pwait.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/epoll_pwait.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/getrlimit.c b/sysdeps/unix/sysv/linux/loongarch/getrlimit.c
new file mode 100644
index 00000000..3960479e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/getrlimit.c
@@ -0,0 +1,45 @@
+/* Linux getrlimit implementation (32 bits rlim_t).
+   Copyright (C) 2016-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+#include <shlib-compat.h>
+
+#if !__RLIM_T_MATCHES_RLIM64_T
+
+/* The __NR_getrlimit compatibility implementation is required iff
+   __NR_ugetrlimit is also defined (meaning an old broken RLIM_INFINITY
+   definition).  */
+# ifndef __NR_ugetrlimit
+#  define __NR_ugetrlimit __NR_getrlimit
+#  undef SHLIB_COMPAT
+#  define SHLIB_COMPAT(a, b, c) 0
+# endif
+
+int
+__new_getrlimit (enum __rlimit_resource resource, struct rlimit *rlim)
+{
+  return INLINE_SYSCALL_CALL (ugetrlimit, resource, rlim);
+}
+weak_alias (__new_getrlimit, __getrlimit)
+hidden_weak (__getrlimit)
+
+weak_alias (__new_getrlimit, getrlimit)
+
+#endif /* __RLIM_T_MATCHES_RLIM64_T  */
diff --git a/sysdeps/unix/sysv/linux/loongarch/internal-signals.h b/sysdeps/unix/sysv/linux/loongarch/internal-signals.h
new file mode 100644
index 00000000..139d6f25
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/internal-signals.h
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/internal-signals.h>
diff --git a/sysdeps/unix/sysv/linux/loongarch/ppoll.c b/sysdeps/unix/sysv/linux/loongarch/ppoll.c
new file mode 100644
index 00000000..ab7b2225
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/ppoll.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/ppoll.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/pselect.c b/sysdeps/unix/sysv/linux/loongarch/pselect.c
new file mode 100644
index 00000000..7fc3ee71
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/pselect.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/pselect.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/pthread_sigmask.c b/sysdeps/unix/sysv/linux/loongarch/pthread_sigmask.c
new file mode 100644
index 00000000..c44ea32a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/pthread_sigmask.c
@@ -0,0 +1,61 @@
+/* Copyright (C) 2002-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <pthreadP.h>
+#include <sysdep.h>
+
+
+int
+pthread_sigmask (int how, const sigset_t *newmask, sigset_t *oldmask)
+{
+  sigset_t local_newmask;
+
+  /* The only thing we have to make sure here is that SIGCANCEL and
+     SIGSETXID is not blocked.  */
+  if (newmask != NULL
+      && (__builtin_expect (__sigismember (newmask, SIGCANCEL), 0)
+	  || __builtin_expect (__sigismember (newmask, SIGSETXID), 0)))
+    {
+      local_newmask = *newmask;
+      __sigdelset (&local_newmask, SIGCANCEL);
+      __sigdelset (&local_newmask, SIGSETXID);
+      newmask = &local_newmask;
+    }
+
+#ifdef INTERNAL_SYSCALL
+  /* We know that realtime signals are available if NPTL is used.  */
+  INTERNAL_SYSCALL_DECL (err);
+  int result = INTERNAL_SYSCALL (rt_sigprocmask, err, 4, how, newmask,
+				 oldmask, _NW_NSIG / 8);
+
+  int rc = (INTERNAL_SYSCALL_ERROR_P (result, err)
+	  ? INTERNAL_SYSCALL_ERRNO (result, err)
+	  : 0);
+  if (rc < 0){
+    return rc;
+  }
+  if (oldmask) {
+    memset((void *)oldmask + _NW_NSIG / 8, 0, (_NSIG - _NW_NSIG) / 8);
+  }
+  return rc;
+#else
+  return sigprocmask (how, newmask, oldmask) == -1 ? errno : 0;
+#endif
+}
diff --git a/sysdeps/unix/sysv/linux/loongarch/sigaction.c b/sysdeps/unix/sysv/linux/loongarch/sigaction.c
new file mode 100644
index 00000000..1ddb8d6c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/sigaction.c
@@ -0,0 +1,257 @@
+/* Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* New ports should not define the obsolete SA_RESTORER, however some
+   architecture requires for compat mode and/or due old ABI.  */
+#include <kernel_sigaction.h>
+
+#ifndef SA_RESTORER
+# define SET_SA_RESTORER(kact, act)
+# define RESET_SA_RESTORER(act, kact)
+#endif
+
+/* SPARC passes the restore function as an argument to rt_sigaction.  */
+#ifndef STUB
+# define STUB(act)
+#endif
+
+#include <sys/ucontext.h>
+
+typedef void (*__linx_sighandler_t)(int, siginfo_t *, void *);
+
+static volatile __linx_sighandler_t saved_handlers[NSIG] = {0};
+
+static void custom_handler(int sig, siginfo_t *info, void *ucontext){
+
+struct nw_sigcontext {
+	unsigned long long	sc_pc;
+	unsigned long long	sc_regs[32];
+	unsigned int	sc_flags;
+	unsigned long long	sc_extcontext[0] __attribute__((__aligned__(16)));
+};
+
+struct nw_ucontext {
+	unsigned long		uc_flags;
+	struct nw_ucontext	*uc_link;
+	stack_t			uc_stack;
+	sigset_t		uc_sigmask;
+	unsigned char  	  __unused[1024 / 8 - sizeof(sigset_t)];
+	struct nw_sigcontext	uc_mcontext;
+};
+
+
+struct nw_sctx_info {
+	unsigned int	magic;
+	unsigned int	size;
+	unsigned long long	padding;	/* padding to 16 bytes */
+};
+
+/* FPU context */
+#define FPU_CTX_MAGIC		0x46505501
+#define FPU_CTX_ALIGN		8
+struct fpu_context {
+	unsigned long long	regs[32];
+	unsigned long long 	fcc;
+	unsigned int	fcsr;
+};
+/* LSX context */
+#define LSX_CTX_MAGIC		0x53580001
+#define LSX_CTX_ALIGN		16
+struct lsx_context {
+	unsigned long long	regs[32][2];
+	unsigned long long	fcc;
+	unsigned long long	fcsr;
+};
+/* LASX context */
+#define LASX_CTX_MAGIC		0x41535801
+#define LASX_CTX_ALIGN		32
+struct lasx_context {
+	unsigned long long	regs[32][4];
+	unsigned long long	fcc;
+	unsigned long long	fcsr;
+};
+
+    struct ucontext_t ow_ctx;
+
+    struct nw_ucontext *nw_ctx = ucontext;
+
+    
+    ow_ctx.__uc_flags = nw_ctx->uc_flags; 
+    ow_ctx.uc_link = NULL;
+    ow_ctx.uc_stack = nw_ctx->uc_stack;
+    ow_ctx.uc_sigmask = nw_ctx->uc_sigmask;
+
+    ow_ctx.uc_mcontext.__pc = nw_ctx->uc_mcontext.sc_pc;
+    memcpy(&ow_ctx.uc_mcontext.__gregs, &nw_ctx->uc_mcontext.sc_regs, sizeof(ow_ctx.uc_mcontext.__gregs));
+    ow_ctx.uc_mcontext.__flags = nw_ctx->uc_mcontext.sc_flags;
+    ow_ctx.uc_mcontext.__fcsr = 0;
+    ow_ctx.uc_mcontext.__vcsr = 0;
+    ow_ctx.uc_mcontext.__fcc = 0;
+    memset(&ow_ctx.uc_mcontext.__fpregs, 0, sizeof(ow_ctx.uc_mcontext.__fpregs));
+
+    int have_fpu = 0, have_lsx = 0, have_lasx = 0;
+    void *fp_ctx_p = NULL;
+    struct nw_sctx_info *extinfo = (void *)&nw_ctx->uc_mcontext.sc_extcontext;
+    while(extinfo->magic){
+        switch(extinfo->magic){
+	  case FPU_CTX_MAGIC: {
+            struct fpu_context *fp_ctx = (void *)(extinfo + 1);
+	    have_fpu = 1;
+	    fp_ctx_p = fp_ctx;
+	    ow_ctx.uc_mcontext.__fcsr = fp_ctx->fcsr;
+	    ow_ctx.uc_mcontext.__fcc = fp_ctx->fcc;
+            for(int i = 0; i < 32; i++){
+	      ow_ctx.uc_mcontext.__fpregs[i].__val64[0] = fp_ctx->regs[i];
+	    }
+	    break;
+          }
+          case LSX_CTX_MAGIC: {
+            struct lsx_context *fp_ctx = (void *)(extinfo + 1);
+	    have_lsx = 1;
+	    fp_ctx_p = fp_ctx;
+	    ow_ctx.uc_mcontext.__fcsr = fp_ctx->fcsr;
+            ow_ctx.uc_mcontext.__fcc = fp_ctx->fcc;
+	    for(int i = 0; i < 32; i++){
+              ow_ctx.uc_mcontext.__fpregs[i].__val64[0] = fp_ctx->regs[i][0];
+              ow_ctx.uc_mcontext.__fpregs[i].__val64[1] = fp_ctx->regs[i][1];
+	    }
+	    break;
+	  }
+          case LASX_CTX_MAGIC: {
+            struct lasx_context *fp_ctx = (void *)(extinfo + 1);
+	    have_lasx = 1;
+            fp_ctx_p = fp_ctx;
+	    ow_ctx.uc_mcontext.__fcsr = fp_ctx->fcsr;
+            ow_ctx.uc_mcontext.__fcc = fp_ctx->fcc;
+            for(int i = 0; i < 32; i++){
+              ow_ctx.uc_mcontext.__fpregs[i].__val64[0] = fp_ctx->regs[i][0];
+              ow_ctx.uc_mcontext.__fpregs[i].__val64[1] = fp_ctx->regs[i][1];
+              ow_ctx.uc_mcontext.__fpregs[i].__val64[2] = fp_ctx->regs[i][2];
+              ow_ctx.uc_mcontext.__fpregs[i].__val64[3] = fp_ctx->regs[i][3];
+            }
+            break;
+	  }
+        }
+	if ( have_fpu || have_lsx || have_lasx ){
+          break;
+	}
+        extinfo = (struct nw_sctx_info *)((void *)extinfo + extinfo->size);
+    }
+
+    saved_handlers[sig](sig, info, &ow_ctx);
+
+    if (have_lasx){
+      struct lasx_context *fp_ctx = fp_ctx_p; 
+      for(int i = 0; i < 32; i++){
+        fp_ctx->regs[i][0] = ow_ctx.uc_mcontext.__fpregs[i].__val64[0];
+        fp_ctx->regs[i][1] = ow_ctx.uc_mcontext.__fpregs[i].__val64[1];
+        fp_ctx->regs[i][2] = ow_ctx.uc_mcontext.__fpregs[i].__val64[2];
+        fp_ctx->regs[i][3] = ow_ctx.uc_mcontext.__fpregs[i].__val64[3];
+      }
+      fp_ctx->fcc = ow_ctx.uc_mcontext.__fcc;
+      fp_ctx->fcsr = ow_ctx.uc_mcontext.__fcsr;
+    } else if (have_lsx){
+      struct lsx_context *fp_ctx = fp_ctx_p;
+      for(int i = 0; i < 32; i++){
+        fp_ctx->regs[i][0] = ow_ctx.uc_mcontext.__fpregs[i].__val64[0];
+        fp_ctx->regs[i][1] = ow_ctx.uc_mcontext.__fpregs[i].__val64[1];
+      }
+      fp_ctx->fcc = ow_ctx.uc_mcontext.__fcc;
+      fp_ctx->fcsr = ow_ctx.uc_mcontext.__fcsr;
+    } else if (have_fpu){
+      struct fpu_context *fp_ctx = fp_ctx_p;
+      for(int i = 0; i < 32; i++){
+        fp_ctx->regs[i] = ow_ctx.uc_mcontext.__fpregs[i].__val64[0];
+      }
+      fp_ctx->fcc = ow_ctx.uc_mcontext.__fcc;
+      fp_ctx->fcsr = ow_ctx.uc_mcontext.__fcsr;
+    }
+    nw_ctx->uc_mcontext.sc_flags = ow_ctx.uc_mcontext.__flags;
+    memcpy(&nw_ctx->uc_mcontext.sc_regs, &ow_ctx.uc_mcontext.__gregs, sizeof(nw_ctx->uc_mcontext.sc_regs));
+    nw_ctx->uc_mcontext.sc_pc = ow_ctx.uc_mcontext.__pc;
+    nw_ctx->uc_sigmask = ow_ctx.uc_sigmask;
+    nw_ctx->uc_stack = ow_ctx.uc_stack;
+    nw_ctx->uc_flags = ow_ctx.__uc_flags;
+}
+
+static inline int is_fake_handler(__linx_sighandler_t handler){
+    return handler == (__linx_sighandler_t) SIG_ERR
+        || handler == (__linx_sighandler_t) SIG_DFL
+        || handler == (__linx_sighandler_t) SIG_IGN
+#ifdef SIG_HOLD
+        || handler == (__linx_sighandler_t) SIG_HOLD
+#endif
+           ;
+}
+
+
+/* If ACT is not NULL, change the action for SIG to *ACT.
+   If OACT is not NULL, put the old action for SIG in *OACT.  */
+int
+__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+  int result;
+
+  struct kernel_sigaction kact, koact;
+
+  __linx_sighandler_t orig_handler = saved_handlers[sig];
+
+  if (act)
+    {
+      if (!is_fake_handler((__linx_sighandler_t)(act)->sa_handler)){ 
+          orig_handler = atomic_exchange_acq(&saved_handlers[sig], (__linx_sighandler_t)act->sa_handler);
+	  kact.k_sa_handler = (__sighandler_t)custom_handler;
+      }else{
+          kact.k_sa_handler = act->sa_handler;
+      }
+      memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));
+      kact.sa_flags = act->sa_flags;
+      SET_SA_RESTORER (&kact, act);
+    }
+
+  /* XXX The size argument hopefully will have to be changed to the
+     real size of the user-level sigset_t.  */
+  result = INLINE_SYSCALL_CALL (rt_sigaction, sig,
+				act ? &kact : NULL,
+				oact ? &koact : NULL, STUB(act) _NW_NSIG / 8);
+
+  if (oact && result >= 0)
+    {
+      if(koact.k_sa_handler == (__sighandler_t)custom_handler){
+        oact->sa_handler = (__sighandler_t)orig_handler;
+      } else {
+        oact->sa_handler = koact.k_sa_handler;
+      }
+      memcpy (&oact->sa_mask, &koact.sa_mask, _NW_NSIG / 8);
+      memset ((void *)&oact->sa_mask + (_NW_NSIG / 8), 0, (_NSIG - _NW_NSIG) / 8);
+      oact->sa_flags = koact.sa_flags;
+      RESET_SA_RESTORER (oact, &koact);
+    }else if(result < 0){
+       atomic_exchange_acq(&saved_handlers[sig], orig_handler);
+    }
+  return result;
+}
+libc_hidden_def (__libc_sigaction)
+
+#include <nptl/sigaction.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/signalfd.c b/sysdeps/unix/sysv/linux/loongarch/signalfd.c
new file mode 100644
index 00000000..d1467d44
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/signalfd.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/signalfd.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/sigpending.c b/sysdeps/unix/sysv/linux/loongarch/sigpending.c
new file mode 100644
index 00000000..307c7ae5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/sigpending.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+
+int
+sigpending (sigset_t *set)
+{
+  int rc = INLINE_SYSCALL (rt_sigpending, 2, set, _NW_NSIG / 8);
+  if (rc < 0){
+    return rc;
+  }
+  memset((void *)set + _NW_NSIG / 8, 0, (_NSIG - _NW_NSIG) / 8);
+  return rc;
+}
diff --git a/sysdeps/unix/sysv/linux/loongarch/sigprocmask.c b/sysdeps/unix/sysv/linux/loongarch/sigprocmask.c
new file mode 100644
index 00000000..3af1c2d7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/sigprocmask.c
@@ -0,0 +1,57 @@
+/* Copyright (C) 1997-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>  /* Needed for string function builtin redirection.  */
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <nptl/pthreadP.h>              /* SIGCANCEL, SIGSETXID */
+
+
+/* Get and/or change the set of blocked signals.  */
+int
+__sigprocmask (int how, const sigset_t *set, sigset_t *oset)
+{
+  sigset_t local_newmask;
+
+  /* The only thing we have to make sure here is that SIGCANCEL and
+     SIGSETXID are not blocked.  */
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)))
+    {
+      local_newmask = *set;
+      __sigdelset (&local_newmask, SIGCANCEL);
+      __sigdelset (&local_newmask, SIGSETXID);
+      set = &local_newmask;
+    }
+
+  int rc = INLINE_SYSCALL (rt_sigprocmask, 4, how, set, oset, _NSIG / 8);
+  if ( rc < 0 ){
+    return rc;
+  }
+  if (oset){
+    memset((void *)set + _NW_NSIG / 8, 0, (_NSIG - _NW_NSIG) / 8);
+  }
+  return rc;
+}
+libc_hidden_def (__sigprocmask)
+weak_alias (__sigprocmask, sigprocmask)
diff --git a/sysdeps/unix/sysv/linux/loongarch/sigsuspend.c b/sysdeps/unix/sysv/linux/loongarch/sigsuspend.c
new file mode 100644
index 00000000..2e14b724
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/sigsuspend.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/sigsuspend.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/sigtimedwait.c b/sysdeps/unix/sysv/linux/loongarch/sigtimedwait.c
new file mode 100644
index 00000000..b9399713
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/sigtimedwait.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/sigtimedwait.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/timer_routines.c b/sysdeps/unix/sysv/linux/loongarch/timer_routines.c
new file mode 100644
index 00000000..c49255ab
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/timer_routines.c
@@ -0,0 +1,6 @@
+#include <signal.h>
+
+#undef _NSIG
+#define _NSIG _NW_NSIG
+
+#include <sysdeps/unix/sysv/linux/timer_routines.c>
diff --git a/sysdeps/unix/sysv/linux/loongarch/ucontext_i.sym b/sysdeps/unix/sysv/linux/loongarch/ucontext_i.sym
index d7f612fe..1fce94fc 100644
--- a/sysdeps/unix/sysv/linux/loongarch/ucontext_i.sym
+++ b/sysdeps/unix/sysv/linux/loongarch/ucontext_i.sym
@@ -8,7 +8,7 @@
 SIG_BLOCK
 SIG_SETMASK
 
-_NSIG8				(_NSIG / 8)
+_NSIG8				(_NW_NSIG / 8)
 
 -- Offsets of the fields in the ucontext_t structure.
 #define ucontext(member)	offsetof (ucontext_t, member)
